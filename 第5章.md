## 对对象读取属性值、设置属性值、apply 等

## 函数调用属于复合操作，如 obj.fn()，先读取 obj.fn,再调用它

## Reflect 是全局对象，它的方法跟 Proxy 的拦截器方法名相同

```js
// 等价
const obj = { foo: 1 };
obj.foo;
Reflect.get(obj, "foo");
```

## Reflect 等三个参数是 receiver，可以理解为 this

```js
const obj = { foo: 1 };
Reflect.get(obj, "foo", { foo: 2 }); //输出是2
```

## 修改原始对象是不会触发副作用的

```js
const obj = {
  foo: 1,
  get bar() {
    return this.foo; // this.foo指的是obj.foo，期望应该是p.foo(代理后的对象)
  },
};
effect(() => {
  console.log(p.bar);
});

p.foo++;
// 副作用不会执行,原因同标题
```

## 解决

```
const p = new  Proxy(obj,{
  get(target,key,receiver){
    track(target,key)
    return Reflect.get(target,key,receiver)
  }
})
```

## 如何区分普通对象和函数

函数会部署内部方法[[Call]]，普通对象不会

## 什么是普通对象，什么是异质对象

- 表 5-1 11 个内置方法都必须使用 ECMA 规范实现
- 内部方法[[Call]]必须使用 ECMA 规范实现
- 内部方法[[Construct]]必须使用 ECMA 规范实现

任意一条不符合就是异质对象，proxy 就是异质对象

创建代理对象时指定拦截函数，实际上是用自定义代理对象本身的内部方法和行为，而不是被代理对象的

## 拦截 in 操作符

```js
const obj = { foo: 1 };
const p = new Proxy(obj, {
  has(target, key) {
    track(target, key);
    return Reflect.has(target, key);
  },
});
```

## EnumerateObjectProperties 实现

```js
// obj就是被for...in的对象
function* EnumerateObjectProperties(obj) {
  const visited = new Set();
  for (const key of Reflect.ownKeys(obj)) {
    if (typeof key === "symbol") continue;
    const desc = Reflect.getOwnProprotyDescriptor(key);
    if (desc) {
      visited.add(key);
      if (desc.enumerable) yield key;
    }
  }
  const proto = Reflect.getPrototypeOf(obj);
  if (proto === null) {
    return;
  }
  for (const protoKey of EnumerateObjectProperties(proto)) {
    if (visited.has(protoKey)) continue;
    yield protoKey;
  }
}
```

## 通过 EnumerateObjectProperties 得知，拦截 ownKeys 可以实现 for...in 代理

```
const obj = { foo: 1 };
const ITERATE_KEY = Symbol()
const p = new Proxy(obj, {
  ownKeys(target, key) {
    track(target, ITERATE_KEY);
    return Reflect.ownKeys(target);
  },
});
```

P98
